"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLatestAlphaTag = void 0;
const htmlparser = require('htmlparser2'); // eslint-disable-line @typescript-eslint/no-var-requires
const node_fetch_1 = __importDefault(require("node-fetch"));
const getProxyAgent_1 = require("./getProxyAgent");
async function getLatestAlphaTag() {
    const objects = [];
    let isTruncated = false;
    let nextContinuationToken = undefined;
    do {
        const url = getUrl(nextContinuationToken);
        const xml = await node_fetch_1.default(url, { agent: getProxyAgent_1.getProxyAgent(url) }).then((res) => res.text());
        const result = await getObjects(xml);
        isTruncated = result.isTruncated;
        nextContinuationToken = result.nextContinuationToken;
        objects.push(...result.objects);
    } while (isTruncated && nextContinuationToken);
    return findLatestAlphaTag(objects);
}
exports.getLatestAlphaTag = getLatestAlphaTag;
function getUrl(nextContinuationToken) {
    var _a;
    const prefix = (_a = process.env.PATCH_BRANCH) !== null && _a !== void 0 ? _a : `master`;
    let url = `https://prisma-builds.s3-eu-west-1.amazonaws.com/?list-type=2&prefix=${prefix}`;
    if (nextContinuationToken) {
        url += `&continuation-token=${encodeURIComponent(nextContinuationToken)}`;
    }
    return url;
}
async function getObjects(xml) {
    return new Promise((resolve) => {
        const parser = new htmlparser.Parser(new htmlparser.DomHandler((err, result) => {
            const bucketTag = result.find((child) => child.name === 'listbucketresult');
            if (!bucketTag) {
                resolve({
                    objects: [],
                    isTruncated: false,
                    nextContinuationToken: null,
                });
            }
            const isTruncated = getKey(bucketTag, 'istruncated');
            const nextContinuationToken = getKey(bucketTag, 'nextcontinuationtoken');
            resolve({
                objects: bucketTag.children
                    .filter((c) => c.name === 'contents')
                    .map((child) => {
                    return child.children.reduce((acc, curr) => {
                        acc[curr.name] = curr.children[0].data;
                        return acc;
                    }, {});
                }),
                isTruncated,
                nextContinuationToken,
            });
        }));
        parser.write(xml);
        parser.end();
    });
}
function findLatestAlphaTag(objects) {
    // look for the darwin build, as it always finishes last
    objects = objects.filter((o) => o.key.includes('darwin'));
    objects.sort((a, b) => {
        // sort  beta to the complete end
        if (!a.key.startsWith('master') || a.key.startsWith('master/latest')) {
            return 1;
        }
        if (!b.key.startsWith('master') || b.key.startsWith('master/latest')) {
            return -1;
        }
        // sort last modified descending
        return new Date(a.lastmodified) < new Date(b.lastmodified) ? 1 : -1;
    });
    return objects[0].key.split('/')[1];
}
function getKey(parentTag, key) {
    if (!parentTag) {
        return null;
    }
    const tag = parentTag.children.find((c) => c.name === key);
    if (tag) {
        return serializeTag(tag);
    }
    return null;
}
function serializeTag(tag) {
    if (tag.children) {
        return tag.children
            .map((c) => {
            if (typeof c.data !== 'undefined') {
                return serializeData(c.data);
            }
            if (c.children) {
                return serializeTag(c);
            }
            return null;
        })
            .join('');
    }
    return null;
}
function serializeData(data) {
    if (data === 'false') {
        return false;
    }
    if (data === 'true') {
        return true;
    }
    return data;
}
//# sourceMappingURL=getLatestAlphaTag.js.map