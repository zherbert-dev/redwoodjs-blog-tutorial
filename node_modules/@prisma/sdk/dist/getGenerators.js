"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.knownBinaryTargets = exports.skipIndex = exports.getGenerator = exports.getGenerators = void 0;
const fs_1 = __importDefault(require("fs"));
const p_map_1 = __importDefault(require("p-map"));
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const fetch_engine_1 = require("@prisma/fetch-engine");
const get_platform_1 = require("@prisma/get-platform");
const engine_core_1 = require("@prisma/engine-core");
const engineCommands_1 = require("./engineCommands");
const unique_1 = require("./unique");
const pick_1 = require("./pick");
const Generator_1 = require("./Generator");
const resolveOutput_1 = require("./resolveOutput");
const predefinedGeneratorResolvers_1 = require("./predefinedGeneratorResolvers");
const flatMap_1 = require("./utils/flatMap");
const missingGeneratorMessage_1 = require("./utils/missingGeneratorMessage");
const defaultEngineVersion = eval(`require('../package.json').prisma.version`);
/**
 * Makes sure that all generators have the binaries they deserve and returns a
 * `Generator` class per generator defined in the schema.prisma file.
 * In other words, this is basically a generator factory function.
 * @param schemaPath Path to schema.prisma
 * @param aliases Aliases like `prisma-client-js` -> `node_modules/@prisma/client/generator-build/index.js`
 */
function getGenerators({ schemaPath, providerAliases: aliases, // do you get the pun?
version, cliVersion, printDownloadProgress, baseDir = path_1.default.dirname(schemaPath), overrideGenerators, skipDownload, }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!schemaPath) {
            throw new Error(`schemaPath for getGenerators got invalid value ${schemaPath}`);
        }
        if (!fs_1.default.existsSync(schemaPath)) {
            throw new Error(`${schemaPath} does not exist`);
        }
        const platform = yield get_platform_1.getPlatform();
        let prismaPath = undefined;
        // overwrite query engine if the version is provided
        if (version) {
            const downloadParams = {
                binaries: {
                    'query-engine': eval(`require('path').join(__dirname, '..')`),
                },
                binaryTargets: [platform],
                showProgress: false,
                version,
                skipDownload,
            };
            const binaryPathsWithEngineType = yield fetch_engine_1.download(downloadParams);
            prismaPath = binaryPathsWithEngineType['query-engine'][platform];
        }
        const datamodel = fs_1.default.readFileSync(schemaPath, 'utf-8');
        const dmmf = yield engineCommands_1.getDMMF({
            datamodel,
            datamodelPath: schemaPath,
            prismaPath,
        });
        if (dmmf.datamodel.models.length === 0) {
            throw new Error(missingGeneratorMessage_1.missingModelMessage);
        }
        const config = yield engineCommands_1.getConfig({
            datamodel,
            datamodelPath: schemaPath,
            prismaPath,
            ignoreEnvVarErrors: true,
        });
        const generatorConfigs = overrideGenerators || config.generators;
        yield validateGenerators(generatorConfigs);
        const runningGenerators = [];
        try {
            // 1. Get all generators
            const generators = yield p_map_1.default(generatorConfigs, (generator, index) => __awaiter(this, void 0, void 0, function* () {
                let generatorPath = generator.provider;
                let paths;
                // as of now mostly used by studio
                if (aliases && aliases[generator.provider]) {
                    generatorPath = aliases[generator.provider].generatorPath;
                    paths = aliases[generator.provider];
                    if (!fs_1.default.existsSync(generatorPath)) {
                        throw new Error(`Could not find generator executable ${aliases[generator.provider].generatorPath} for generator ${generator.provider}`);
                    }
                }
                else if (predefinedGeneratorResolvers_1.predefinedGeneratorResolvers[generator.provider]) {
                    paths = yield predefinedGeneratorResolvers_1.predefinedGeneratorResolvers[generator.provider](baseDir, cliVersion);
                    generatorPath = paths.generatorPath;
                }
                const generatorInstance = new Generator_1.Generator(generatorPath);
                yield generatorInstance.init();
                // resolve output path
                if (generator.output) {
                    generator.output = path_1.default.resolve(baseDir, generator.output);
                    generator.isCustomOutput = true;
                }
                else if (paths) {
                    generator.output = paths.outputPath;
                }
                else {
                    if (!generatorInstance.manifest ||
                        !generatorInstance.manifest.defaultOutput) {
                        throw new Error(`Can't resolve output dir for generator ${chalk_1.default.bold(generator.name)} with provider ${chalk_1.default.bold(generator.provider)}.
The generator needs to either define the \`defaultOutput\` path in the manifest or you need to define \`output\` in the datamodel.prisma file.`);
                    }
                    generator.output = yield resolveOutput_1.resolveOutput({
                        defaultOutput: generatorInstance.manifest.defaultOutput,
                        baseDir,
                    });
                }
                const options = {
                    datamodel,
                    datasources: config.datasources,
                    generator,
                    dmmf,
                    otherGenerators: skipIndex(generatorConfigs, index),
                    schemaPath,
                    version: version || defaultEngineVersion,
                };
                // we set the options here a bit later after instantiating the Generator,
                // as we need the generator manifest to resolve the `output` dir
                generatorInstance.setOptions(options);
                runningGenerators.push(generatorInstance);
                return generatorInstance;
            }), {
                stopOnError: false,
            });
            // 2. Download all binaries and binary targets needed
            const binaries = flatMap_1.flatMap(generators, (g) => g.manifest ? g.manifest.requiresEngines || [] : []);
            let binaryTargets = unique_1.unique(flatMap_1.flatMap(generatorConfigs, (g) => g.binaryTargets || [])).map((t) => (t === 'native' ? platform : t));
            if (binaryTargets.length === 0) {
                binaryTargets = [platform];
            }
            if (process.env.NETLIFY && !binaryTargets.includes('rhel-openssl-1.0.x')) {
                binaryTargets.push('rhel-openssl-1.0.x');
            }
            const binariesConfig = binaries.reduce((acc, curr) => {
                acc[engineTypeToBinaryType(curr)] = eval(`require('path').join(__dirname, '..')`);
                return acc;
            }, {});
            const downloadParams = {
                binaries: binariesConfig,
                binaryTargets: binaryTargets,
                showProgress: typeof printDownloadProgress === 'boolean'
                    ? printDownloadProgress
                    : true,
                version: version || defaultEngineVersion,
                skipDownload,
            };
            const binaryPathsWithEngineType = yield fetch_engine_1.download(downloadParams);
            const binaryPaths = mapKeys(binaryPathsWithEngineType, binaryTypeToEngineType);
            for (const generator of generators) {
                if (generator.manifest && generator.manifest.requiresEngines) {
                    const generatorBinaryPaths = pick_1.pick(binaryPaths, generator.manifest.requiresEngines);
                    generator.setBinaryPaths(generatorBinaryPaths);
                }
            }
            return generators;
        }
        catch (e) {
            // make sure all generators that are already running are being stopped
            runningGenerators.forEach((g) => g.stop());
            throw e;
        }
    });
}
exports.getGenerators = getGenerators;
/**
 * Shortcut for getGenerators, if there is only one generator defined. Useful for testing.
 * @param schemaPath path to schema.prisma
 * @param aliases Aliases like `photonjs` -> `node_modules/photonjs/gen.js`
 * @param version Version of the binary, commit hash of https://github.com/prisma/prisma-engine/commits/master
 * @param printDownloadProgress `boolean` to print download progress or not
 */
function getGenerator(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const generators = yield getGenerators(options);
        return generators[0];
    });
}
exports.getGenerator = getGenerator;
function skipIndex(arr, index) {
    return [...arr.slice(0, index), ...arr.slice(index + 1)];
}
exports.skipIndex = skipIndex;
exports.knownBinaryTargets = [
    'native',
    'darwin',
    'debian-openssl-1.0.x',
    'debian-openssl-1.1.x',
    'rhel-openssl-1.0.x',
    'rhel-openssl-1.1.x',
    'linux-musl',
    'linux-nixos',
    'windows',
    'freebsd',
    'openbsd',
    'netbsd',
    'arm',
];
const oldToNewBinaryTargetsMapping = {
    'linux-glibc-libssl1.0.1': 'debian-openssl-1.0.x',
    'linux-glibc-libssl1.0.2': 'debian-openssl-1.0.x',
    'linux-glibc-libssl1.1.0': 'debian-openssl1.1.x',
};
function validateGenerators(generators) {
    return __awaiter(this, void 0, void 0, function* () {
        const platform = yield get_platform_1.getPlatform();
        for (const generator of generators) {
            if (generator.provider === 'photonjs') {
                throw new Error(`Oops! Photon has been renamed to Prisma Client. Please make the following adjustments:
  1. Rename ${chalk_1.default.red('provider = "photonjs"')} to ${chalk_1.default.green('provider = "prisma-client-js"')} in your ${chalk_1.default.bold('schema.prisma')} file.
  2. Replace your ${chalk_1.default.bold('package.json')}'s ${chalk_1.default.red('@prisma/photon')} dependency to ${chalk_1.default.green('@prisma/client')}
  3. Replace ${chalk_1.default.red("import { Photon } from '@prisma/photon'")} with ${chalk_1.default.green("import { PrismaClient } from '@prisma/client'")} in your code.
  4. Run ${chalk_1.default.green('prisma generate')} again.
      `);
            }
            if (generator.provider === 'nexus-prisma') {
                throw new Error('`nexus-prisma` is no longer a generator. You can read more at https://pris.ly/nexus-prisma-upgrade-0.4');
            }
            if (generator.config.platforms) {
                throw new Error(`The \`platforms\` field on the generator definition is deprecated. Please rename it to \`binaryTargets\`.`);
            }
            if (generator.config.pinnedPlatform) {
                throw new Error(`The \`pinnedPlatform\` field on the generator definition is deprecated.
Please use the PRISMA_QUERY_ENGINE_BINARY env var instead to pin the binary target.`);
            }
            if (generator.binaryTargets) {
                for (const binaryTarget of generator.binaryTargets) {
                    if (oldToNewBinaryTargetsMapping[binaryTarget]) {
                        throw new Error(`Binary target ${chalk_1.default.red.bold(binaryTarget)} is deprecated. Please use ${chalk_1.default.green.bold(oldToNewBinaryTargetsMapping[binaryTarget])} instead.`);
                    }
                    if (!exports.knownBinaryTargets.includes(binaryTarget)) {
                        throw new Error(`Unknown binary target ${chalk_1.default.red(binaryTarget)} in generator ${chalk_1.default.bold(generator.name)}.
Possible binaryTargets: ${chalk_1.default.greenBright(exports.knownBinaryTargets.join(', '))}`);
                    }
                }
                const binaryTargets = generator.binaryTargets && generator.binaryTargets.length > 0
                    ? generator.binaryTargets
                    : ['native'];
                const resolvedBinaryTargets = binaryTargets.map((p) => p === 'native' ? platform : p);
                if (!resolvedBinaryTargets.includes(platform)) {
                    if (generator) {
                        console.log(`${chalk_1.default.yellow('Warning:')} Your current platform \`${chalk_1.default.bold(platform)}\` is not included in your generator's \`binaryTargets\` configuration ${JSON.stringify(generator.binaryTargets)}.
    To fix it, use this generator config in your ${chalk_1.default.bold('schema.prisma')}:
    ${chalk_1.default.greenBright(engine_core_1.printGeneratorConfig(Object.assign(Object.assign({}, generator), { binaryTargets: engine_core_1.fixPlatforms(generator.binaryTargets, platform) })))}
    ${chalk_1.default.gray(`Note, that by providing \`native\`, Prisma Client automatically resolves \`${platform}\`.
    Read more about deploying Prisma Client: ${chalk_1.default.underline('https://github.com/prisma/prisma/blob/master/docs/core/generators/prisma-client-js.md')}`)}\n`);
                    }
                    else {
                        console.log(`${chalk_1.default.yellow('Warning')} The binaryTargets ${JSON.stringify(binaryTargets)} don't include your local platform ${platform}, which you can also point to with \`native\`.
    In case you want to fix this, you can provide ${chalk_1.default.greenBright(`binaryTargets: ${JSON.stringify(['native', ...(binaryTargets || [])])}`)} in the schema.prisma file.`);
                    }
                }
            }
        }
    });
}
function engineTypeToBinaryType(engineType) {
    if (engineType === 'introspectionEngine') {
        return 'introspection-engine';
    }
    if (engineType === 'migrationEngine') {
        return 'migration-engine';
    }
    if (engineType === 'queryEngine') {
        return 'query-engine';
    }
    if (engineType === 'prismaFmt') {
        return 'prisma-fmt';
    }
    throw new Error(`Could not convert engine type ${engineType}`);
}
function binaryTypeToEngineType(binaryType) {
    if (binaryType === 'introspection-engine') {
        return 'introspectionEngine';
    }
    if (binaryType === 'migration-engine') {
        return 'migrationEngine';
    }
    if (binaryType === 'query-engine') {
        return 'queryEngine';
    }
    if (binaryType === 'prisma-fmt') {
        return 'prismaFmt';
    }
    throw new Error(`Could not convert binary type ${binaryType}`);
}
function mapKeys(obj, mapper) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
        acc[mapper(key)] = value;
        return acc;
    }, {});
}
//# sourceMappingURL=getGenerators.js.map