"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeErrorReportCompleted = exports.createErrorReport = exports.ErrorKind = exports.sendPanic = void 0;
const get_platform_1 = require("@prisma/get-platform");
const archiver_1 = __importDefault(require("archiver"));
const debug_1 = __importDefault(require("@prisma/debug"));
const fs_1 = __importDefault(require("fs"));
const globby_1 = __importDefault(require("globby"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const tmp_1 = __importDefault(require("tmp"));
const checkpoint = __importStar(require("checkpoint-client"));
const maskSchema_1 = require("./utils/maskSchema");
const panic_1 = require("./panic");
const fetch_engine_1 = require("@prisma/fetch-engine");
const IntrospectionEngine_1 = require("./IntrospectionEngine");
const debug = debug_1.default('sendPanic');
// cleanup the temporary files even when an uncaught exception occurs
tmp_1.default.setGracefulCleanup();
function sendPanic(error, cliVersion, binaryVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let schema;
            let maskedSchema;
            if (error.schemaPath) {
                schema = fs_1.default.readFileSync(error.schemaPath, 'utf-8');
            }
            if (error.schema) {
                schema = error.schema;
            }
            if (schema) {
                maskedSchema = maskSchema_1.maskSchema(schema);
            }
            let sqlDump;
            if (error.area === panic_1.ErrorArea.INTROSPECTION_CLI && error.introspectionUrl) {
                let engine;
                try {
                    engine = new IntrospectionEngine_1.IntrospectionEngine();
                    sqlDump = yield engine.getDatabaseDescription(error.introspectionUrl);
                    engine.stop();
                }
                catch (e) {
                    if (engine && engine.isRunning) {
                        engine.stop();
                    }
                    debug(e);
                }
            }
            const liftRequest = error.request
                ? JSON.stringify(maskSchema_1.mapScalarValues(error.request, (value) => {
                    if (typeof value === 'string') {
                        return maskSchema_1.maskSchema(value);
                    }
                    return value;
                }))
                : undefined;
            const signedUrl = yield createErrorReport({
                area: error.area,
                kind: ErrorKind.RUST_PANIC,
                cliVersion,
                binaryVersion,
                command: getCommand(),
                jsStackTrace: strip_ansi_1.default(error.stack || error.message),
                rustStackTrace: error.rustStack,
                operatingSystem: `${os_1.default.arch()} ${os_1.default.platform()} ${os_1.default.release()}`,
                platform: yield get_platform_1.getPlatform(),
                liftRequest,
                schemaFile: maskedSchema,
                fingerprint: checkpoint.signature.sync(),
                sqlDump,
            });
            if (error.schemaPath) {
                const zip = yield makeErrorZip(error);
                yield uploadZip(zip, signedUrl);
            }
            const id = yield makeErrorReportCompleted(signedUrl);
            return id;
        }
        catch (e) {
            debug(e);
        }
    });
}
exports.sendPanic = sendPanic;
function getCommand() {
    if (process.argv[2] === 'introspect') {
        // don't send url
        return 'introspect';
    }
    return process.argv.slice(2).join(' ');
}
function uploadZip(zip, url) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield node_fetch_1.default(url, {
            method: 'PUT',
            agent: fetch_engine_1.getProxyAgent(url),
            headers: {
                'Content-Length': String(zip.byteLength),
            },
            body: zip,
        });
    });
}
function makeErrorZip(error) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!error.schemaPath) {
            throw new Error(`Can't make zip without schema path`);
        }
        const schemaDir = path_1.default.dirname(error.schemaPath);
        const tmpFileObj = tmp_1.default.fileSync();
        const outputFile = fs_1.default.createWriteStream(tmpFileObj.name);
        const zip = archiver_1.default('zip', { zlib: { level: 9 } });
        zip.pipe(outputFile);
        // add schema file
        const schemaFile = maskSchema_1.maskSchema(fs_1.default.readFileSync(error.schemaPath, 'utf-8'));
        zip.append(schemaFile, { name: path_1.default.basename(error.schemaPath) });
        if (fs_1.default.existsSync(schemaDir)) {
            const filePaths = yield globby_1.default('migrations/**/*', {
                cwd: schemaDir,
            });
            for (const filePath of filePaths) {
                let file = fs_1.default.readFileSync(path_1.default.resolve(schemaDir, filePath), 'utf-8');
                if (filePath.endsWith('schema.prisma') ||
                    filePath.endsWith(path_1.default.basename(error.schemaPath))) {
                    // Remove credentials from schema datasource url
                    file = maskSchema_1.maskSchema(file);
                }
                zip.append(file, { name: path_1.default.basename(filePath) });
            }
        }
        zip.finalize();
        return new Promise((resolve, reject) => {
            outputFile.on('close', () => {
                const buffer = fs_1.default.readFileSync(tmpFileObj.name);
                resolve(buffer);
            });
            zip.on('error', (err) => {
                reject(err);
            });
        });
    });
}
var ErrorKind;
(function (ErrorKind) {
    ErrorKind["JS_ERROR"] = "JS_ERROR";
    ErrorKind["RUST_PANIC"] = "RUST_PANIC";
})(ErrorKind = exports.ErrorKind || (exports.ErrorKind = {}));
function createErrorReport(data) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield request(`mutation ($data: CreateErrorReportInput!) {
    createErrorReport(data: $data)
  }`, { data });
        return result.createErrorReport;
    });
}
exports.createErrorReport = createErrorReport;
function makeErrorReportCompleted(signedUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield request(`mutation ($signedUrl: String!) {
  markErrorReportCompleted(signedUrl: $signedUrl)
}`, { signedUrl });
        return result.markErrorReportCompleted;
    });
}
exports.makeErrorReportCompleted = makeErrorReportCompleted;
function request(query, variables) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = 'https://error-reports.prisma.sh/';
        const body = JSON.stringify({
            query,
            variables,
        });
        return yield node_fetch_1.default(url, {
            method: 'POST',
            agent: fetch_engine_1.getProxyAgent(url),
            body,
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        })
            .then((res) => res.json())
            .then((res) => {
            if (res.errors) {
                throw new Error(JSON.stringify(res.errors));
            }
            return res.data;
        });
    });
}
//# sourceMappingURL=sendPanic.js.map