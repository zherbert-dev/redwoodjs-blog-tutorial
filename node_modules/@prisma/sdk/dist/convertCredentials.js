"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.databaseTypeToConnectorType = exports.uriToCredentials = exports.credentialsToUri = void 0;
const url_parse_1 = __importDefault(require("url-parse"));
function credentialsToUri(credentials) {
    const type = databaseTypeToProtocol(credentials.type);
    if (credentials.type === 'mongo') {
        return credentials.uri;
    }
    const url = new url_parse_1.default(type + '//', true);
    if (credentials.host) {
        url.hostname = credentials.host;
    }
    if (credentials.type === 'postgresql') {
        if (credentials.database) {
            url.pathname = '/' + credentials.database;
        }
        if (credentials.schema) {
            url.query.schema = credentials.schema;
        }
        if (credentials.socket) {
            url.query.host = credentials.socket;
        }
    }
    else if (credentials.type === 'mysql') {
        url.pathname = '/' + (credentials.database || credentials.schema || '');
        if (credentials.socket) {
            url.query.socket = credentials.socket;
        }
    }
    if (credentials.ssl) {
        url.query.sslmode = 'prefer';
    }
    if (credentials.user) {
        url.username = credentials.user;
    }
    if (credentials.password) {
        url.password = credentials.password;
    }
    if (credentials.port) {
        url.port = String(credentials.port);
    }
    url.host = `${url.hostname}${url.port ? `:${url.port}` : ''}`;
    if (credentials.extraFields) {
        for (const [key, value] of Object.entries(credentials.extraFields)) {
            url.query[key] = value;
        }
    }
    // trim away empty pathnames
    if (url.pathname === '/') {
        url.pathname = '';
    }
    // use a custom toString method, as we don't want escaping of query params
    return url.toString((q) => Object.entries(q)
        .map(([key, value]) => `${key}=${value}`)
        .join('&'));
}
exports.credentialsToUri = credentialsToUri;
function uriToCredentials(connectionString) {
    const uri = new url_parse_1.default(connectionString, true);
    const type = protocolToDatabaseType(uri.protocol);
    // needed, as the URL implementation adds empty strings
    const exists = (str) => str && str.length > 0;
    if (type === 'mongo') {
        return {
            type,
            uri: connectionString,
        };
    }
    const _a = uri.query, { schema, socket, host } = _a, extraFields = __rest(_a, ["schema", "socket", "host"]);
    return {
        type,
        host: exists(uri.hostname) ? uri.hostname : undefined,
        user: exists(uri.username) ? uri.username : undefined,
        port: exists(uri.port) ? Number(uri.port) : undefined,
        password: exists(uri.password) ? uri.password : undefined,
        database: uri.pathname && uri.pathname.length > 1
            ? uri.pathname.slice(1)
            : undefined,
        schema: uri.query.schema || undefined,
        uri: connectionString,
        ssl: Boolean(uri.query.sslmode),
        socket: uri.query.socket || uri.query.host,
        extraFields,
    };
}
exports.uriToCredentials = uriToCredentials;
function databaseTypeToProtocol(databaseType) {
    switch (databaseType) {
        case 'postgresql':
            return 'postgresql:';
        case 'mysql':
            return 'mysql:';
        case 'mongo':
            return 'mongodb:';
        case 'sqlite':
            return 'sqlite:';
    }
}
function protocolToDatabaseType(protocol) {
    switch (protocol) {
        case 'postgresql:':
        case 'postgres:':
            return 'postgresql';
        case 'mongodb:':
            return 'mongo';
        case 'mysql:':
            return 'mysql';
        case 'file:':
        case 'sqlite:':
            return 'sqlite';
    }
    throw new Error(`Unknown database type ${protocol}`);
}
function databaseTypeToConnectorType(databaseType) {
    switch (databaseType) {
        case 'postgresql':
            return 'postgresql';
        case 'mysql':
            return 'mysql';
        case 'sqlite':
            return 'sqlite';
    }
    throw new Error(`Mongo is not yet supported`);
}
exports.databaseTypeToConnectorType = databaseTypeToConnectorType;
//# sourceMappingURL=convertCredentials.js.map