"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.replaceParams = exports.validatePath = exports.parseSearch = exports.matchPath = exports.createNamedContext = void 0;

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/get-iterator"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));

var _getIteratorMethod2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/get-iterator-method"));

var _symbol = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/symbol"));

var _from = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/from"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));

var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/starts-with"));

var _keys2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/keys"));

var _urlSearchParams = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/url-search-params"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/concat"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));

var _objectSpread4 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/objectSpread2"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _matchAll = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/match-all"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _react = _interopRequireDefault(require("react"));

function _createForOfIteratorHelper(o) { if (typeof _symbol.default === "undefined" || (0, _getIteratorMethod2.default)(o) == null) { if ((0, _isArray.default)(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2.default)(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { var _context7; if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = (0, _slice.default)(_context7 = Object.prototype.toString.call(o)).call(_context7, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return (0, _from.default)(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/** Create a React Context with the given name. */
var createNamedContext = function createNamedContext(name, defaultValue) {
  var Ctx = _react.default.createContext(defaultValue);

  Ctx.displayName = name;
  return Ctx;
};
/**
 * Get param name and type transform for a route
 *
 *  '/blog/{year}/{month}/{day:Int}' => [['year'], ['month'], ['day', 'Int']]
 */


exports.createNamedContext = createNamedContext;

var paramsForRoute = function paramsForRoute(route) {
  var _context;

  // Match the strings between `{` and `}`.
  var params = (0, _toConsumableArray2.default)((0, _matchAll.default)(route).call(route, /\{([^}]+)\}/g));
  return (0, _map.default)(_context = (0, _map.default)(params).call(params, function (match) {
    return match[1];
  })).call(_context, function (match) {
    return match.split(':');
  });
};
/** Definitions of the core param types. */


var coreParamTypes = {
  Int: {
    constraint: /\d+/,
    transform: Number
  }
};
/**
 * Determine if the given route is a match for the given pathname. If so,
 * extract any named params and return them in an object.
 *
 * route         - The route path as specified in the <Route path={...} />
 * pathname      - The pathname from the window.location.
 * allParamTypes - The object containing all param type definitions.
 *
 * Examples:
 *
 *  matchPath('/blog/{year}/{month}/{day}', '/blog/2019/12/07')
 *  => { match: true, params: { year: '2019', month: '12', day: '07' }}
 *
 *  matchPath('/about', '/')
 *  => { match: false }
 *
 *  matchPath('/post/{id:Int}', '/post/7')
 *  => { match: true, params: { id: 7 }}
 */

var matchPath = function matchPath(route, pathname, paramTypes) {
  var _context2;

  // Get the names and the transform types for the given route.
  var routeParams = paramsForRoute(route);
  var allParamTypes = (0, _objectSpread4.default)((0, _objectSpread4.default)({}, coreParamTypes), paramTypes);
  var typeConstrainedRoute = route; // Map all params from the route to their type constraint regex to create a "type-constrained route" regexp

  var _iterator = _createForOfIteratorHelper(routeParams),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _context3;

      var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
          name = _step$value[0],
          type = _step$value[1];

      var typeRegex = '[^/]+';
      var constraint = type && allParamTypes[type].constraint;

      if (constraint) {
        // Get the type
        typeRegex = constraint.toString() || '/[^/]+/';
        typeRegex = typeRegex.substring(1, typeRegex.length - 1);
      }

      typeConstrainedRoute = typeConstrainedRoute.replace(type ? (0, _concat.default)(_context3 = "{".concat(name, ":")).call(_context3, type, "}") : "{".concat(name, "}"), "(".concat(typeRegex, ")"));
    } // Does the `pathname` match the route?

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var matches = (0, _toConsumableArray2.default)((0, _matchAll.default)(pathname).call(pathname, "^".concat(typeConstrainedRoute, "$")));

  if (matches.length === 0) {
    return {
      match: false
    };
  } // Map extracted values to their param name, casting the value if needed


  var providedParams = (0, _slice.default)(_context2 = matches[0]).call(_context2, 1);
  var params = (0, _reduce.default)(providedParams).call(providedParams, function (acc, value, index) {
    var _routeParams$index = (0, _slicedToArray2.default)(routeParams[index], 2),
        name = _routeParams$index[0],
        transformName = _routeParams$index[1];

    var typeInfo = allParamTypes[transformName];

    if (typeInfo && typeof typeInfo.transform === 'function') {
      value = typeInfo.transform(value);
    }

    return (0, _objectSpread4.default)((0, _objectSpread4.default)({}, acc), {}, (0, _defineProperty2.default)({}, name, value));
  }, {});
  return {
    match: true,
    params: params
  };
};
/**
 * Parse the given search string into key/value pairs and return them in an
 * object.
 *
 * Examples:
 *
 *  parseSearch('?key1=val1&key2=val2')
 *  => { key1: 'val1', key2: 'val2' }
 *
 * @fixme
 * This utility ignores keys with multiple values such as `?foo=1&foo=2`.
 */


exports.matchPath = matchPath;

var parseSearch = function parseSearch(search) {
  var _context4;

  var searchParams = new _urlSearchParams.default(search);
  return (0, _reduce.default)(_context4 = (0, _toConsumableArray2.default)((0, _keys2.default)(searchParams).call(searchParams))).call(_context4, function (params, key) {
    return (0, _objectSpread4.default)((0, _objectSpread4.default)({}, params), {}, (0, _defineProperty2.default)({}, key, searchParams.get(key)));
  }, {});
};
/**
 * Validate a path to make sure it follows the router's rules. If any problems
 * are found, a descriptive Error will be thrown, as problems with routes are
 * critical enough to be considered fatal.
 */


exports.parseSearch = parseSearch;

var validatePath = function validatePath(path) {
  // Check that path begins with a slash.
  if (!(0, _startsWith.default)(path).call(path, '/')) {
    throw new Error("Route path does not begin with a slash: \"".concat(path, "\""));
  }

  if ((0, _indexOf.default)(path).call(path, ' ') >= 0) {
    throw new Error("Route path contains spaces: \"".concat(path, "\""));
  } // Check for duplicate named params.


  var matches = (0, _matchAll.default)(path).call(path, /\{([^}]+)\}/g);
  var memo = {};

  var _iterator2 = _createForOfIteratorHelper(matches),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var match = _step2.value;
      // Extract the param's name to make sure there aren't any duplicates
      var param = match[1].split(':')[0];

      if (memo[param]) {
        throw new Error("Route path contains duplicate parameter: \"".concat(path, "\""));
      } else {
        memo[param] = true;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
};
/**
 * Take a given route path and replace any named parameters with those in the
 * given args object. Any extra params not used in the path will be appended
 * as key=value pairs in the search part.
 *
 * Examples:
 *
 *   replaceParams('/tags/{tag}', { tag: 'code', extra: 'foo' })
 *   => '/tags/code?extra=foo
 */


exports.validatePath = validatePath;

var replaceParams = function replaceParams(path) {
  var _context5;

  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // Split the path apart and replace named parameters with those sent in,
  // then join it back together.
  var parts = path.split('/');
  var newPath = (0, _map.default)(parts).call(parts, function (part) {
    if (part[0] === '{' && part[part.length - 1] === '}') {
      var paramSpec = part.substr(1, part.length - 2);
      var paramName = paramSpec.split(':')[0];
      var arg = args[paramName];

      if (arg) {
        delete args[paramName];
        return arg;
      }
    }

    return part;
  }).join('/'); // Prepare any unnamed params to be be appended as search params.

  var queryParams = [];
  (0, _forEach.default)(_context5 = (0, _keys.default)(args)).call(_context5, function (key) {
    var _context6;

    queryParams.push((0, _concat.default)(_context6 = "".concat(key, "=")).call(_context6, args[key]));
  }); // Append any unnamed params as search params.

  if (queryParams.length) {
    newPath += "?".concat(queryParams.join('&'));
  }

  return newPath;
};

exports.replaceParams = replaceParams;