"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.splitPathAndModel = exports.handler = exports.builder = exports.desc = exports.command = exports.routes = exports.files = void 0;

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _listr = _interopRequireDefault(require("listr"));

var _camelcase = _interopRequireDefault(require("camelcase"));

var _pascalcase = _interopRequireDefault(require("pascalcase"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _paramCase = require("param-case");

var _humanizeString = _interopRequireDefault(require("humanize-string"));

var _lib = require("../../../lib");

var _colors = _interopRequireDefault(require("../../../lib/colors"));

var _helpers = require("../helpers");

var _sdl = require("../sdl/sdl");

var _service = require("../service/service");

const NON_EDITABLE_COLUMNS = ['id', 'createdAt', 'updatedAt'];

const ASSETS = _fs.default.readdirSync(_path.default.join(_lib.templateRoot, 'scaffold', 'templates', 'assets'));

const LAYOUTS = _fs.default.readdirSync(_path.default.join(_lib.templateRoot, 'scaffold', 'templates', 'layouts'));

const PAGES = _fs.default.readdirSync(_path.default.join(_lib.templateRoot, 'scaffold', 'templates', 'pages'));

const COMPONENTS = _fs.default.readdirSync(_path.default.join(_lib.templateRoot, 'scaffold', 'templates', 'components'));

const SCAFFOLD_STYLE_PATH = './scaffold.css'; // Any assets that should not trigger an overwrite error and require a --force

const SKIPPABLE_ASSETS = ['scaffold.css'];

const getIdType = model => {
  var _model$fields$find, _context;

  return (_model$fields$find = (0, _find.default)(_context = model.fields).call(_context, field => field.isId)) === null || _model$fields$find === void 0 ? void 0 : _model$fields$find.type;
};

const files = async ({
  model: name,
  path: scaffoldPath = ''
}) => {
  const model = await (0, _lib.getSchema)((0, _pascalcase.default)(_pluralize.default.singular(name)));
  return { ...(await (0, _sdl.files)({
      name,
      crud: true
    })),
    ...(await (0, _service.files)({
      name,
      crud: true,
      relations: (0, _helpers.relationsForModel)(model)
    })),
    ...assetFiles(name),
    ...layoutFiles(name, scaffoldPath),
    ...pageFiles(name, scaffoldPath),
    ...(await componentFiles(name, scaffoldPath))
  };
};

exports.files = files;

const assetFiles = name => {
  let fileList = {};
  (0, _forEach.default)(ASSETS).call(ASSETS, asset => {
    const outputAssetName = asset.replace(/\.template/, '');

    const outputPath = _path.default.join((0, _lib.getPaths)().web.src, outputAssetName); // skip assets that already exist on disk, never worry about overwriting


    if (!(0, _includes.default)(SKIPPABLE_ASSETS).call(SKIPPABLE_ASSETS, _path.default.basename(outputPath)) || !_fs.default.existsSync(outputPath)) {
      const template = (0, _lib.generateTemplate)(_path.default.join('scaffold', 'templates', 'assets', asset), {
        name
      });
      fileList[outputPath] = template;
    }
  });
  return fileList;
};

const layoutFiles = (name, scaffoldPath = '') => {
  var _context2;

  const pluralName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  let fileList = {};
  const pascalScaffoldPath = scaffoldPath === '' ? scaffoldPath : (0, _map.default)(_context2 = scaffoldPath.split('/')).call(_context2, _pascalcase.default).join('/') + '/';
  const pluralCamelName = (0, _camelcase.default)(pluralName);
  const camelScaffoldPath = (0, _camelcase.default)((0, _pascalcase.default)(scaffoldPath));
  const pluralRouteName = scaffoldPath === '' ? pluralCamelName : `${camelScaffoldPath}${pluralName}`;
  const newRouteName = scaffoldPath === '' ? `new${singularName}` : `${camelScaffoldPath}New${singularName}`;
  (0, _forEach.default)(LAYOUTS).call(LAYOUTS, layout => {
    const outputLayoutName = layout.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.template/, '');

    const outputPath = _path.default.join((0, _lib.getPaths)().web.layouts, pascalScaffoldPath, outputLayoutName.replace(/\.js/, ''), outputLayoutName);

    const template = (0, _lib.generateTemplate)(_path.default.join('scaffold', 'templates', 'layouts', layout), {
      name,
      pascalScaffoldPath,
      pluralRouteName,
      newRouteName
    });
    fileList[outputPath] = template;
  });
  return fileList;
};

const pageFiles = (name, scaffoldPath = '') => {
  var _context3;

  const pluralName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  let fileList = {};
  const pascalScaffoldPath = scaffoldPath === '' ? scaffoldPath : (0, _map.default)(_context3 = scaffoldPath.split('/')).call(_context3, _pascalcase.default).join('/') + '/';
  (0, _forEach.default)(PAGES).call(PAGES, page => {
    const outputPageName = page.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.template/, '');

    const outputPath = _path.default.join((0, _lib.getPaths)().web.pages, pascalScaffoldPath, outputPageName.replace(/\.js/, ''), outputPageName);

    const template = (0, _lib.generateTemplate)(_path.default.join('scaffold', 'templates', 'pages', page), {
      name,
      pascalScaffoldPath
    });
    fileList[outputPath] = template;
  });
  return fileList;
};

const componentFiles = async (name, scaffoldPath = '') => {
  var _context4, _context5, _context6;

  const pluralName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  const model = await (0, _lib.getSchema)(singularName);
  const idType = getIdType(model);
  const columns = (0, _filter.default)(_context4 = model.fields).call(_context4, field => field.kind !== 'object');
  const intForeignKeys = (0, _helpers.intForeignKeysForModel)(model);
  let fileList = {};
  const editableColumns = (0, _map.default)(_context5 = (0, _filter.default)(columns).call(columns, column => {
    return (0, _indexOf.default)(NON_EDITABLE_COLUMNS).call(NON_EDITABLE_COLUMNS, column.name) === -1;
  })).call(_context5, column => ({ ...column,
    label: (0, _humanizeString.default)(column.name)
  }));
  const pascalScaffoldPath = scaffoldPath === '' ? scaffoldPath : (0, _map.default)(_context6 = scaffoldPath.split('/')).call(_context6, _pascalcase.default).join('/') + '/';
  const pluralCamelName = (0, _camelcase.default)(pluralName);
  const camelScaffoldPath = (0, _camelcase.default)((0, _pascalcase.default)(scaffoldPath));
  const pluralRouteName = scaffoldPath === '' ? pluralCamelName : `${camelScaffoldPath}${pluralName}`;
  const editRouteName = scaffoldPath === '' ? `edit${singularName}` : `${camelScaffoldPath}Edit${singularName}`;
  const singularRouteName = scaffoldPath === '' ? (0, _camelcase.default)(singularName) : `${camelScaffoldPath}${singularName}`;
  const newRouteName = scaffoldPath === '' ? `new${singularName}` : `${camelScaffoldPath}New${singularName}`;
  await (0, _lib.asyncForEach)(COMPONENTS, component => {
    const outputComponentName = component.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.template/, '');

    const outputPath = _path.default.join((0, _lib.getPaths)().web.components, pascalScaffoldPath, outputComponentName.replace(/\.js/, ''), outputComponentName);

    const template = (0, _lib.generateTemplate)(_path.default.join('scaffold', 'templates', 'components', component), {
      name,
      columns,
      editableColumns,
      idType,
      intForeignKeys,
      pascalScaffoldPath,
      pluralRouteName,
      editRouteName,
      singularRouteName,
      newRouteName
    });
    fileList[outputPath] = template;
  });
  return fileList;
}; // add routes for all pages


const routes = async ({
  model: name,
  path: scaffoldPath = ''
}) => {
  var _context7;

  const singularPascalName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  const pluralPascalName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularCamelName = (0, _camelcase.default)(singularPascalName);
  const pluralCamelName = (0, _camelcase.default)(pluralPascalName);
  const pluralParamName = (0, _paramCase.paramCase)(pluralPascalName);
  const model = await (0, _lib.getSchema)(singularPascalName);
  const idRouteParam = getIdType(model) === 'Int' ? ':Int' : '';
  const paramScaffoldPath = scaffoldPath === '' ? scaffoldPath : (0, _map.default)(_context7 = scaffoldPath.split('/')).call(_context7, _paramCase.paramCase).join('/') + '/';
  const pascalScaffoldPath = (0, _pascalcase.default)(scaffoldPath);
  const camelScaffoldPath = (0, _camelcase.default)(pascalScaffoldPath);
  const newRouteName = scaffoldPath === '' ? `new${singularPascalName}` : `${camelScaffoldPath}New${singularPascalName}`;
  const editRouteName = scaffoldPath === '' ? `edit${singularPascalName}` : `${camelScaffoldPath}Edit${singularPascalName}`;
  const singularRouteName = scaffoldPath === '' ? singularCamelName : `${camelScaffoldPath}${singularPascalName}`;
  const pluralRouteName = scaffoldPath === '' ? pluralCamelName : `${camelScaffoldPath}${pluralPascalName}`; // TODO: These names look like they need changing

  return [// new
  `<Route path="/${paramScaffoldPath}${pluralParamName}/new" page={${pascalScaffoldPath}New${singularPascalName}Page} name="${newRouteName}" />`, // edit
  `<Route path="/${paramScaffoldPath}${pluralParamName}/{id${idRouteParam}}/edit" page={${pascalScaffoldPath}Edit${singularPascalName}Page} name="${editRouteName}" />`, // singular
  `<Route path="/${paramScaffoldPath}${pluralParamName}/{id${idRouteParam}}" page={${pascalScaffoldPath}${singularPascalName}Page} name="${singularRouteName}" />`, // plural
  `<Route path="/${paramScaffoldPath}${pluralParamName}" page={${pascalScaffoldPath}${pluralPascalName}Page} name="${pluralRouteName}" />`];
};

exports.routes = routes;

const addScaffoldImport = () => {
  const indexJsPath = _path.default.join((0, _lib.getPaths)().web.src, 'index.js');

  let indexJsContents = (0, _lib.readFile)(indexJsPath).toString();

  if (indexJsContents.match(SCAFFOLD_STYLE_PATH)) {
    return 'Skipping scaffold style include';
  }

  indexJsContents = indexJsContents.replace("import Routes from 'src/Routes'\n", `import Routes from 'src/Routes'\n\nimport '${SCAFFOLD_STYLE_PATH}'`);
  (0, _lib.writeFile)(indexJsPath, indexJsContents, {
    overwriteExisting: true
  });
  return 'Added scaffold import to index.js';
};

const command = 'scaffold <model>';
exports.command = command;
const desc = 'Generate Pages, SDL, and Services files based on a given DB schema Model. Also accepts <path/model>.';
exports.desc = desc;

const builder = yargs => {
  yargs.positional('model', {
    description: "Model to scaffold. You can also use <path/model> to nest files by type at the given path directory (or directories). For example, 'rw g scaffold admin/post'."
  });
  yargs.option('force', {
    default: false,
    type: 'boolean'
  });
};

exports.builder = builder;

const tasks = ({
  model,
  path,
  force
}) => {
  return new _listr.default([{
    title: 'Generating scaffold files...',
    task: async () => {
      const f = await files({
        model,
        path
      });
      return (0, _lib.writeFilesTask)(f, {
        overwriteExisting: force
      });
    }
  }, {
    title: 'Adding scaffold routes...',
    task: async () => {
      return (0, _lib.addRoutesToRouterTask)(await routes({
        model,
        path
      }));
    }
  }, {
    title: 'Adding scaffold asset imports...',
    task: () => addScaffoldImport()
  }], {
    collapse: false,
    exitOnError: true
  });
};

const handler = async ({
  model: modelArg,
  force
}) => {
  const {
    model,
    path
  } = splitPathAndModel(modelArg);
  const t = tasks({
    model,
    path,
    force
  });

  try {
    await t.run();
  } catch (e) {
    console.log(_colors.default.error(e.message));
  }
};

exports.handler = handler;

const splitPathAndModel = pathSlashModel => {
  var _context8;

  const path = (0, _slice.default)(_context8 = pathSlashModel.split('/')).call(_context8, 0, -1).join('/'); // This code will work whether or not there's a path in model
  // E.g. if model is just 'post',
  // path.split('/') will return ['post'].

  const model = pathSlashModel.split('/').pop();
  return {
    model,
    path
  };
};

exports.splitPathAndModel = splitPathAndModel;