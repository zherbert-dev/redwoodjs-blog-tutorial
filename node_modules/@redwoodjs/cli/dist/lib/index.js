"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.runCommandTask = exports.removeRoutesFromRouterTask = exports.addRoutesToRouterTask = exports.cleanupEmptyDirsTask = exports.deleteFilesTask = exports.writeFilesTask = exports.prettierOptions = exports.getPaths = exports.bytes = exports.writeFile = exports.deleteFile = exports.readFile = exports.generateTemplate = exports.templateRoot = exports.nameVariants = exports.getSchemaDefinitions = exports.getEnum = exports.getSchema = exports.asyncForEach = void 0;

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _reverse = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reverse"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/set"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _string = _interopRequireDefault(require("lodash/string"));

var _camelcase = _interopRequireDefault(require("camelcase"));

var _pascalcase = _interopRequireDefault(require("pascalcase"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _decamelize = _interopRequireDefault(require("decamelize"));

var _paramCase = require("param-case");

var _sdk = require("@prisma/sdk");

var _internal = require("@redwoodjs/internal");

var _execa = _interopRequireDefault(require("execa"));

var _listr = _interopRequireDefault(require("listr"));

var _listrVerboseRenderer = _interopRequireDefault(require("listr-verbose-renderer"));

var _prettier = require("prettier");

var _colors = _interopRequireDefault(require("./colors"));

const asyncForEach = async (array, callback) => {
  for (let index = 0; index < array.length; index++) {
    await callback(array[index], index, array);
  }
};
/**
 * Returns the database schema for the given `name` database table parsed from
 * the schema.prisma of the target application. If no `name` is given then the
 * entire schema is returned.
 */


exports.asyncForEach = asyncForEach;

const getSchema = async name => {
  const schema = await getSchemaDefinitions();

  if (name) {
    var _context;

    const model = (0, _find.default)(_context = schema.datamodel.models).call(_context, model => {
      return model.name === name;
    });

    if (model) {
      return model;
    } else {
      throw new Error(`No schema definition found for \`${name}\` in schema.prisma file`);
    }
  }

  return schema.metadata.datamodel;
};
/**
 * Returns the enum defined with the given `name` parsed from
 * the schema.prisma of the target applicaiton. If no `name` is given then the
 * all enum definitions are returned
 */


exports.getSchema = getSchema;

const getEnum = async name => {
  const schema = await getSchemaDefinitions();

  if (name) {
    var _context2;

    const model = (0, _find.default)(_context2 = schema.datamodel.enums).call(_context2, model => {
      return model.name === name;
    });

    if (model) {
      return model;
    } else {
      throw new Error(`No enum schema definition found for \`${name}\` in schema.prisma file`);
    }
  }

  return schema.metadata.datamodel.enums;
};
/*
 * Returns the DMMF defined by `prisma` resolving the relevant `shema.prisma` path.
 */


exports.getEnum = getEnum;

const getSchemaDefinitions = async () => {
  const schemaPath = _path.default.join(getPaths().api.db, 'schema.prisma');

  const metadata = await (0, _sdk.getDMMF)({
    datamodel: readFile(schemaPath.toString())
  });
  return metadata;
};
/**
 * Returns variants of the passed `name` for usage in templates. If the given
 * name was "fooBar" then these would be:

 * pascalName: FooBar
 * singularPascalName: FooBar
 * pluralPascalName: FooBars
 * singularCamelName: fooBar
 * pluralCamelName: fooBars
 * singularParamName: foo-bar
 * pluralParamName: foo-bars
 * singularConstantName: FOO_BAR
 * pluralConstantName: FOO_BARS
*/


exports.getSchemaDefinitions = getSchemaDefinitions;

const nameVariants = name => {
  const normalizedName = (0, _pascalcase.default)((0, _paramCase.paramCase)(_pluralize.default.singular(name)));
  return {
    pascalName: (0, _pascalcase.default)(name),
    camelName: (0, _camelcase.default)(name),
    singularPascalName: normalizedName,
    pluralPascalName: (0, _pluralize.default)(normalizedName),
    singularCamelName: (0, _camelcase.default)(normalizedName),
    pluralCamelName: (0, _camelcase.default)((0, _pluralize.default)(normalizedName)),
    singularParamName: (0, _paramCase.paramCase)(normalizedName),
    pluralParamName: (0, _paramCase.paramCase)((0, _pluralize.default)(normalizedName)),
    singularConstantName: (0, _decamelize.default)(normalizedName).toUpperCase(),
    pluralConstantName: (0, _decamelize.default)((0, _pluralize.default)(normalizedName)).toUpperCase()
  };
};

exports.nameVariants = nameVariants;

const templateRoot = _path.default.resolve(__dirname, '../commands/generate');

exports.templateRoot = templateRoot;

const generateTemplate = (templateFilename, {
  name,
  root,
  ...rest
}) => {
  const templatePath = _path.default.join(root || templateRoot, templateFilename);

  const template = _string.default.template(readFile(templatePath).toString());

  const renderedTemplate = template({
    name,
    ...nameVariants(name),
    ...rest
  }); // We format .js and .css templates, we need to tell prettier which parser
  // we're using.
  // https://prettier.io/docs/en/options.html#parser

  const parser = {
    '.css': 'css',
    '.js': 'babel'
  }[_path.default.extname(templateFilename)];

  if (typeof parser === 'undefined') {
    return renderedTemplate;
  }

  return (0, _prettier.format)(renderedTemplate, { ...prettierOptions(),
    parser
  });
};

exports.generateTemplate = generateTemplate;

const readFile = target => _fs.default.readFileSync(target);

exports.readFile = readFile;

const deleteFile = target => _fs.default.unlinkSync(target);

exports.deleteFile = deleteFile;

const writeFile = (target, contents, {
  overwriteExisting = false
} = {}) => {
  if (!overwriteExisting && _fs.default.existsSync(target)) {
    throw new Error(`${target} already exists.`);
  }

  const filename = _path.default.basename(target);

  const targetDir = target.replace(filename, '');

  _fs.default.mkdirSync(targetDir, {
    recursive: true
  });

  _fs.default.writeFileSync(target, contents);
};

exports.writeFile = writeFile;

const bytes = contents => Buffer.byteLength(contents, 'utf8');
/**
 * This wraps the core version of getPaths into something that catches the exception
 * and displays a helpful error message.
 */


exports.bytes = bytes;

const getPaths = () => {
  try {
    return (0, _internal.getPaths)();
  } catch (e) {
    console.error(_colors.default.error(e.message));
    process.exit(0);
  }
};
/**
 * This returns the config present in `prettier.config.js` of a Redwood project.
 */


exports.getPaths = getPaths;

const prettierOptions = () => {
  try {
    return require(_path.default.join(getPaths().base, 'prettier.config.js'));
  } catch (e) {
    return undefined;
  }
};
/**
 * Creates a list of tasks that write files to the disk.
 *
 * @param files - {[filepath]: contents}
 */


exports.prettierOptions = prettierOptions;

const writeFilesTask = (files, options) => {
  var _context3;

  const {
    base
  } = getPaths();
  return new _listr.default((0, _map.default)(_context3 = (0, _keys.default)(files)).call(_context3, file => {
    const contents = files[file];
    return {
      title: `Writing \`./${_path.default.relative(base, file)}\`...`,
      task: () => writeFile(file, contents, options)
    };
  }));
};
/**
 * Creates a list of tasks that delete files from the disk.
 *
 * @param files - {[filepath]: contents}
 */


exports.writeFilesTask = writeFilesTask;

const deleteFilesTask = files => {
  var _context4;

  const {
    base
  } = getPaths();
  return new _listr.default([...(0, _map.default)(_context4 = (0, _keys.default)(files)).call(_context4, file => {
    return {
      title: `Destroying \`./${_path.default.relative(base, file)}\`...`,
      skip: () => !_fs.default.existsSync(file) && `File doesn't exist`,
      task: () => deleteFile(file)
    };
  }), {
    title: 'Cleaning up empty directories...',
    task: () => cleanupEmptyDirsTask(files)
  }]);
};
/**
 * @param files - {[filepath]: contents}
 */


exports.deleteFilesTask = deleteFilesTask;

const cleanupEmptyDirsTask = files => {
  var _context5;

  const {
    base
  } = getPaths();
  const allDirs = (0, _map.default)(_context5 = (0, _keys.default)(files)).call(_context5, file => _path.default.dirname(file));
  const uniqueDirs = [...new _set.default(allDirs)];
  return new _listr.default((0, _map.default)(uniqueDirs).call(uniqueDirs, dir => {
    return {
      title: `Removing empty \`./${_path.default.relative(base, dir)}\`...`,
      task: () => _fs.default.rmdirSync(dir),
      skip: () => {
        if (!_fs.default.existsSync(dir)) {
          return `Doesn't exist`;
        }

        if (_fs.default.readdirSync(dir).length > 0) {
          return 'Not empty';
        }

        return false;
      }
    };
  }));
};
/**
 * Update the project's routes file.
 */


exports.cleanupEmptyDirsTask = cleanupEmptyDirsTask;

const addRoutesToRouterTask = routes => {
  var _context6;

  const redwoodPaths = getPaths();
  const routesContent = readFile(redwoodPaths.web.routes).toString();
  const newRoutesContent = (0, _reduce.default)(_context6 = (0, _reverse.default)(routes).call(routes)).call(_context6, (content, route) => {
    if ((0, _includes.default)(content).call(content, route)) {
      return content;
    }

    return content.replace(/(\s*)\<Router\>/, `$1<Router>$1  ${route}`);
  }, routesContent);
  writeFile(redwoodPaths.web.routes, newRoutesContent, {
    overwriteExisting: true
  });
};
/**
 * Remove named routes from the project's routes file.
 *
 * @param {string[]} routes - Route names
 */


exports.addRoutesToRouterTask = addRoutesToRouterTask;

const removeRoutesFromRouterTask = routes => {
  const redwoodPaths = getPaths();
  const routesContent = readFile(redwoodPaths.web.routes).toString();
  const newRoutesContent = (0, _reduce.default)(routes).call(routes, (content, route) => {
    const matchRouteByName = new RegExp(`\\s*<Route[^>]*name="${route}"[^>]*/>`);
    return content.replace(matchRouteByName, '');
  }, routesContent);
  writeFile(redwoodPaths.web.routes, newRoutesContent, {
    overwriteExisting: true
  });
};

exports.removeRoutesFromRouterTask = removeRoutesFromRouterTask;

const runCommandTask = async (commands, {
  verbose
}) => {
  const tasks = new _listr.default((0, _map.default)(commands).call(commands, ({
    title,
    cmd,
    args,
    opts = {}
  }) => ({
    title,
    task: async () => {
      return (0, _execa.default)(cmd, args, {
        shell: true,
        cwd: `${getPaths().base}/api`,
        stdio: verbose ? 'inherit' : 'pipe',
        extendEnv: true,
        cleanup: true,
        ...opts
      });
    }
  })), {
    renderer: verbose && _listrVerboseRenderer.default,
    dateFormat: false
  });

  try {
    await tasks.run();
    return true;
  } catch (e) {
    console.log(_colors.default.error(e.message));
    return false;
  }
};

exports.runCommandTask = runCommandTask;